 __________________________________________________________
|        Differences Between Python 2 & Python 3           |
|__________________________________________________________|
|           Python 2          |          Python 3          |
|_____________________________|____________________________|
| print "NoNeedBrackets"      | print("BracketsRequired")  |
|_____________________________|____________________________|
| print "ASCII"               | print("AlwaysUnicode")     |
| print u"ThisIsUnicode"      | print("AlwaysUnicode")     |
|_____________________________|____________________________|
| int/int = int (5/2=2)       | int/int =~ float (5/2=2.5) |
|_____________________________|____________________________|
| raw_input() reads string    | raw_input() not available  |
|_____________________________|____________________________|
| input() evaluates data read | input() reads string       |
|_____________________________|____________________________|
| generator.next()            | next(generator)            |
|_____________________________|____________________________|
| -                           | py2to3utility              |
|_____________________________|____________________________|
| Indent. w both tabs & spcs  | disallows mixing           |
|_____________________________|____________________________|

_______________________________________________________________________________
PEP 8 - Style Guide for Python Code (https://www.python.org/dev/peps/pep-0008/)
--- INDENTATION ---
- Use 4 spaces per indentation level. Although PEP 8 recommends to use spaces over tabs, in my opinion, it is more convenient to use tabs for indentation for the sake of not spamming space button every time over and over again. Whichever way is chosen, it must be followed throughout the whole code as Python 3 no more allows a mixed use of tabs and spaces.

- Aligned with opening delimiter.
    foo = long_function_name(var_one, var_two,
                            var_three, var_four)

- Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)

- Hanging indents should add a level.
    foo = long_function_name(
        var_one, var_two,
        var_three, var_four)

- The closing brace/bracket/parenthesis on multiline constructs may either line up under the first non-whitespace character of the last line of list, as in:
    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]

- or it may be lined up under the first character of the line that starts the multiline construct, as in:
    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]

--- MAXIMUM LINE LENGTH ---
- Limit all lines to a maximum of 79 characters. For flowing long blocks of text with fewer structural restrictions (docstrings or comments), the line length should be limited to 72 characters. Backslashes may still be appropriate at times. For example, long, multiple with-statements cannot use implicit continuation, so "backslashes" are acceptable:
    with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
        file_2.write(file_1.read())

--- LINE BREAK ---
- Following the tradition from mathematics usually results in more readable code:

- easy to match operators with operands
    income = (gross_wages
              + taxable_interest
              + (dividends - qualified_dividends)
              - ira_deduction
              - student_loan_interest)

--- IMPORTS ---
- Imports should usually be on separate lines:
    import os
    import sys

--- WHITESPACES ---
- Avoid extraneous whitespace in the following situations:

- Immediately inside parentheses, brackets or braces:
    spam(ham[1], {eggs: 2})

- Between a trailing comma and a following close parenthesis:
    foo = (0,)

- Immediately before a comma, semicolon, or colon:
    if x == 4: print x, y; x, y = y, x

- However, in a slice the colon acts like a binary operator, and should have equal amounts on either side (treating it as the operator with the lowest priority). In an extended slice, both colons must have the same amount of spacing applied. Exception: when a slice parameter is omitted, the space is omitted:
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]

- Immediately before the open parenthesis that starts the argument list of a function call:
    spam(1)

- Immediately before the open parenthesis that starts an indexing or slicing:
    dct['key'] = lst[index]

- More than one space around an assignment (or other) operator to align it with another:
    x = 1
    y = 2
    long_variable = 3

--- OTHER RECOMMENDETATIONS ON WHITESPACING ---
- Always surround these binary operators with a single space on either side: assignment (=), augmented assignment (+=, -= etc.), comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not), Booleans (and, or, not).

- If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator:
    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)

- Don't use spaces around the = sign when used to indicate a keyword argument, or when used to indicate a default value for an unannotated function parameter:
    def complex(real, imag=0.0):
        return magic(r=real, i=imag)

- When combining an argument annotation with a default value, however, do use spaces around the = sign:
    def munge(sep: AnyStr = None): ...
    def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...

--- COMMENTS ---
- Comments in python are written by square '#' and it doesn't support multi-line commenting. After the square '#' always leave one space. (I indently don't put a space after square when I use inline comments.)

- Inline comments are unnecessary and in fact distracting if they state the obvious. 

--- DOCUMENTATION STRINGS ---
- Write docstrings for all public modules, functions, classes, and methods. Docstrings are not necessary for non-public methods, but you should have a comment that describes what the method does. This comment should appear after the def line.

- We write docstrings inside a double triple quotes,
    """Return a foobang

    Optional plotz says to frobnicate the bizbaz first.
    """

- For one liner docstrings, please keep the closing """ on the same line.

--- NAMING CONVENTIONS ---
- Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names. Conventions for every data type:

  1.Package and Module Names
  Modules should have short, all-lowercase names. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged,
    import mymathlib

  2.Class Names
  Class names should normally use the CapWords convention.
    class MyHolyClass:
      ...

  3.Exception Names
  Because exceptions should be classes, the class naming convention applies here. However, you should use the suffix "Error" on your exception names (if the exception actually is an error).
    class ValidationError(Exception):
      ...

  4.Function and Variable Names
  Function names should be lowercase, with words separated by underscores as necessary to improve readability. Variable names follow the same convention as function names. mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility.
    def my_sacred_func():
      ....
    my_own_var = 52
    # or in the latter scenario,
    mixedCasedVariable = 81

  5.Global Variable Names
  The conventions are about the same as those for functions,
    my_global_var = "everywhere"

  6.Method Names and Instance Variables
  Use the function naming rules: lowercase with words separated by underscores as necessary to improve readability. Use one leading underscore only for non-public methods and instance variables. (Although PEP8 says so, mixedCase can also be used)
    def instance_method(self):
      ...
    @classmethod
    def class_method(cls):
      ...
    @staticmethod
    def static_method():
      ...

  7.Function and Method Arguments
  Always use 'self' for the first argument to instance methods. Always use cls for the 'first' argument to class methods,
    # Example of different method types: (https://levelup.gitconnected.com/method-types-in-python-2c95d46281cd)
    class MethodTypes:

      name = "Ragnar"

      def instance_method(self):
        # Creates an instance atribute through keyword self
        self.lastname = "Lothbrock"
        print(self.name)
        print(self.lastname)

      @classmethod
      def class_method(cls):
        # Access a class atribute through keyword cls
        cls.name = "Lagertha"
        print(cls.name)

      @staticmethod
      def static_method():
        print("This is a static method")

    # Creates an instance of the class
    m = MethodTypes()
    # Calls instance method
    m.instance_method()
    
    MethodTypes.class_method()
    MethodTypes.static_method()

  8.Constants
  Constants are usually defined on a module level and written in all capital letters with underscores separating words,
    MAX_OVERFLOW
_______________________________________________________________________________

- There is no type declaration while creating variables in Python,
    a = 32
    b = "python"

- Comments in python are written by square '#' and it doesn't support multi-line commenting.

- String concetenation,
    "python" + " three" #'python three'

- 2 * 2 #4
  "ab" * 2 #'abab'

- Lists (called as arrays in other languages) in python are created with square brackets '[]'. The items in a list don't have to be of same type,
    my_list = [] #creating an empty list
    ["my first item"]
    ["my first item", "my second item", "true"] #this 'true' is a string
    ["my first item", "my second item", 52, True, False] #booleans in python start with capitalized letters

- It is a much more better to use to stick with one usage along the code, for example using just single quotes '' or double quotes "" while handling strings. It increases the readability and stability of the code.

- List indexing starts from 0 in python. Also string indexing...
    my_list = ["good job", "nice", "well done"]
    my_list[0] #'good job'
    "vivaldi"[0] #'v'
  PS: my_list[10] #IndexError: list index out of range

Some List Operations
  1. list.append(element)
    Lets us add a new elemet at the end of a list,
      my_list = [1, 2, 3, 4, 4]
      my_list.append(5)
      my_list #[1, 2, 3, 4, 4, 5]
  2. list.pop()
    Lets us remove the last elemet of a list,
      my_list.pop()
      my_list #[1, 2, 3, 4, 4]
  3. list.pop(index)
    Lets us remove the element at the given index,
      my_list.pop(1) #2
      my_list #[1, 3, 4, 4]
  4. len(list)
    Gives us the length of the list. It is also usable with strings,
      len(my_list) #4
      len("no string dude") #14
  5. list.count(element)
    Returns count of how many times 'element' occurs in list,
      my_list.count(4) #2
  6. list.extend(list2)
    Appends the contents of 'list2' to 'list'. If we type a 'string' instead of 'list2' it will append all single letters one by one to the list,
      extra = [5, 6, 6, 7]
      my_list.extend(extra)
      my_list #[1, 3, 4, 4, 5, 6, 6, 7]
      my_list.extend("op")
      my_list #[1, 3, 4, 4, 5, 6, 6, 7, 'o', 'p']
  7. list.index(element)
    Returns the lowest index in the list that element appears on,
      my_list.index(4) #2
  8. list.insert(index, element)
    Inserts 'element' into list at offset index,
      my_list.insert(1, 2)
      my_list #[1, 2, 3, 4, 4, 5, 6, 6, 7, 'o', 'p',]
  9. list.remove(element)
    Removes the element that is on the lowest index from list if multiple. If there is just one from the element it simply removes it,
      my_list.remove(4)
      my_list #[1, 2, 3, 4, 5, 6, 6, 7, 'o', 'p']
      my_list.remove('o')
      my_list #[1, 2, 3, 4, 5, 6, 6, 7, 'p']
  10.list.reverse()
    Reverses the list,
      my_list.reverse()
      my_list #['p', 7, 6, 6, 5, 4, 3, 2, 1]
  11.sorted(list)
    Returns a sorted version of 'list' regarding the 'key'. Does not alter the original list. It sorts from lowest to highest (from a to z on strings),
      list_1 = [1, 52, 5, 66, 33, 27]
      sorted(list_1) #[1, 5, 27, 33, 52, 66]
      list_2 = ["mehmet", "ali", "zeynep", "kadir"]
      sorted(list_2) #["ali", "kadir", "mehmet", "zeynep"]
  12.sorted(list, reverse=True)
    Returns a reverse-sorted version of 'list' regarding the 'key'. Does not alter the original list. It sorts from highest to lowest (from z to a on strings),
      sorted(list_1, reverse=True) #[66, 52, 33, 27, 5, 1]
      sorted(list_2, reverse=True) #["zeynep", "mehmet", "kadir", "ali"]
  13.sorted(list, key, reverse)
    Returns a sorted version of 'list' based on the 'key'. On demand reverse property can also be used by setting to True or False. Does not alter the original list.
    key=len provides a sorting based on the length of the words, from shortest to longest,
      list_3 = ["mike", "alexandra", "joe"]
      sorted(list_1, key=len) #["joe", "mike", "alexandra"]
    key=str.lower Hiddenly converts all strings to lowercase to help to sort it in the correct way, if we don't use this sorted function will sort the words beginning with uppercased and lowercased seperately because it actually sorts them according to their UNICODE values, that's why it will first sort the ones beginning with capitalized letters within theirselves and the ones beginning with lowercased letters within thierselves seperately,
      names_with_case = ['Harry', 'Suzy', 'al', 'mark']
      # sorting w/o using 'key=str.lower' property
      sorted(names_with_case) #['Harry', 'Suzy', 'al', 'mark']
      # sorting with using 'key=str.lower' property
      sorted(names_with_case, key=str.lower) #['al', 'Harry', 'mark', 'Suzy']
    As well as pre-defined functions, user-defined functions can also be used with 'key' argument,
      In below code, it simply reverses the string and then evaluates the first letter for sorting, which in conclusion means they are being sorted based on their last letters,
        def reverse_word(word):
          return word[::-1]
        words = ['banana', 'pie', 'Washington', 'book']
        sorted(words, key=reverse_word) #['banana', 'pie', 'book', 'Washington']
  14.list.sort()
    Sorts the 'list' from lowest to highest (from a to z on strings). It modifies the original list in place and returns 'None',
      values_to_sort = [5, 2, 6, 1]
      values_to_sort.sort()
      values_to_sort #[1, 2, 5, 6]
  14.list.sort(key, reverse)
    All the properties in 'sorted' of 'key' and 'reverse' also apply here... Furthermore here we can mention about anonymous (lambda in python) functions,
      In below code, it simply reverses the string and then evaluates the first letter for sorting, which in conclusion means they are being sorted based on their last letters but in the reverse order this time unlike the one above,
        words = ['banana', 'pie', 'Washington', 'book']
        words.sort(key=lambda x: x[::-1], reverse=True)
        words #['Washington', 'book', 'pie', 'banana']

Dictionaries
Dictionaries are like lists but they consist of key-value pairs and curly braces around them. We can use both strings and integers as keys in both python 2 and 3 unlike the other languages. We can have lists, tuples or dictionaries inside dictionaries
  my_dict = {
    "name": "Omer",
    "age": 24,
    "isCool": True,
    52: "Ordu",
    my_listing = [1, 2, 3],
    inner_dict = {
      "salut": "hello"
    }
  }

We can reassign values to the keys,
  my_dict["isCool"] #True
  my_dict["isCool"] = False
  my_dict["isCool"] #False

We can create a new key-value pair,
  my_dict[66] = "Yozgat"

If I try to a nonexistent key, I get KeyError,
  my_dict["surname"] #KeyError: 'surname'
  my_dict[3] #KeyError: 3

Tuples
Unlike lists and dictionaries, tuples are immutable like strings and so cannot be changed,
  my_tup = (1, 2, (4, 5), [21, 54])

But lists or dictionaries inside of a tuple can be changed,
  my_tup[3][1] = 9
  my_tup #1, 2, (4, 5), [21, 9])

Also however, we can add things to the tuple,
  my_tup += "append me man"
  my_tup #(1, 2, (4, 5), [21, 54], "append me man")
  my_tup += ((9)) #TypeError
  my_tup += (("9")) #TypeError
  my_tup += ((9),)
  my_tup #(1, 2, (4, 5), [21, 54], 9)
  my_tup += ((9,10))
  my_tup #(1, 2, (4, 5), [21, 54], 9, 9, 10)
  my_tup += ((12, 13),)
  my_tup #(1, 2, (4, 5), [21, 54], 9, 9, 10, (12, 13))