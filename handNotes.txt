 __________________________________________________________
|        Differences Between Python 2 & Python 3           |
|__________________________________________________________|
|           Python 2          |          Python 3          |
|_____________________________|____________________________|
| print "NoNeedBrackets"      | print("BracketsRequired")  |
|_____________________________|____________________________|
| print "ASCII"               | print("AlwaysUnicode")     |
| print u"ThisIsUnicode"      | print("AlwaysUnicode")     |
|_____________________________|____________________________|
| int/int = int (5/2=2)       | int/int =~ float (5/2=2.5) |
|_____________________________|____________________________|
| raw_input() reads string    | raw_input() not available  |
|_____________________________|____________________________|
| input() evaluates data read | input() reads string       |
|_____________________________|____________________________|
| generator.next()            | next(generator)            |
|_____________________________|____________________________|
| -                           | py2to3utility              |
|_____________________________|____________________________|
| Indent. w both tabs & spcs  | disallows mixing           |
|_____________________________|____________________________|

_______________________________________________________________________________
PEP 8 - Style Guide for Python Code (https://www.python.org/dev/peps/pep-0008/)
--- INDENTATION ---
- Use 4 spaces per indentation level. Although PEP 8 recommends to use spaces over tabs, in my opinion, it is more convenient to use tabs for indentation for the sake of not spamming space button every time over and over again. Whichever way is chosen, it must be followed throughout the whole code as Python 3 no more allows a mixed use of tabs and spaces.

- Aligned with opening delimiter.
    foo = long_function_name(var_one, var_two,
                            var_three, var_four)

- Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)

- Hanging indents should add a level.
    foo = long_function_name(
        var_one, var_two,
        var_three, var_four)

- The closing brace/bracket/parenthesis on multiline constructs may either line up under the first non-whitespace character of the last line of list, as in:
    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]

- or it may be lined up under the first character of the line that starts the multiline construct, as in:
    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]

--- MAXIMUM LINE LENGTH ---
- Limit all lines to a maximum of 79 characters. For flowing long blocks of text with fewer structural restrictions (docstrings or comments), the line length should be limited to 72 characters. Backslashes may still be appropriate at times. For example, long, multiple with-statements cannot use implicit continuation, so "backslashes" are acceptable:
    with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
        file_2.write(file_1.read())

--- LINE BREAK ---
- Following the tradition from mathematics usually results in more readable code:

- easy to match operators with operands
    income = (gross_wages
              + taxable_interest
              + (dividends - qualified_dividends)
              - ira_deduction
              - student_loan_interest)

--- IMPORTS ---
- Imports should usually be on separate lines:
    import os
    import sys

--- WHITESPACES ---
- Avoid extraneous whitespace in the following situations:

- Immediately inside parentheses, brackets or braces:
    spam(ham[1], {eggs: 2})

- Between a trailing comma and a following close parenthesis:
    foo = (0,)

- Immediately before a comma, semicolon, or colon:
    if x == 4: print x, y; x, y = y, x

- However, in a slice the colon acts like a binary operator, and should have equal amounts on either side (treating it as the operator with the lowest priority). In an extended slice, both colons must have the same amount of spacing applied. Exception: when a slice parameter is omitted, the space is omitted:
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]

- Immediately before the open parenthesis that starts the argument list of a function call:
    spam(1)

- Immediately before the open parenthesis that starts an indexing or slicing:
    dct['key'] = lst[index]

- More than one space around an assignment (or other) operator to align it with another:
    x = 1
    y = 2
    long_variable = 3

--- OTHER RECOMMENDETATIONS ON WHITESPACING ---
- Always surround these binary operators with a single space on either side: assignment (=), augmented assignment (+=, -= etc.), comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not), Booleans (and, or, not).

- If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator:
    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)

- Don't use spaces around the = sign when used to indicate a keyword argument, or when used to indicate a default value for an unannotated function parameter:
    def complex(real, imag=0.0):
        return magic(r=real, i=imag)

- When combining an argument annotation with a default value, however, do use spaces around the = sign:
    def munge(sep: AnyStr = None): ...
    def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...

--- COMMENTS ---
- Comments in python are written by square '#' and it doesn't support multi-line commenting. After the square '#' always leave one space

- Inline comments are unnecessary and in fact distracting if they state the obvious. 

--- DOCUMENTATION STRINGS ---
- Write docstrings for all public modules, functions, classes, and methods. Docstrings are not necessary for non-public methods, but you should have a comment that describes what the method does. This comment should appear after the def line.

- We write docstrings inside a double triple quotes,
    """Return a foobang

    Optional plotz says to frobnicate the bizbaz first.
    """

- For one liner docstrings, please keep the closing """ on the same line.

--- NAMING CONVENTIONS ---
- Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names. Conventions for every data type:

  1.Package and Module Names
  Modules should have short, all-lowercase names. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged,
    import mymathlib

  2.Class Names
  Class names should normally use the CapWords convention.
    class MyHolyClass:
      ...

  3.Exception Names
  Because exceptions should be classes, the class naming convention applies here. However, you should use the suffix "Error" on your exception names (if the exception actually is an error).
    class ValidationError(Exception):
      ...

  4.Function and Variable Names
  Function names should be lowercase, with words separated by underscores as necessary to improve readability. Variable names follow the same convention as function names. mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility.
    def my_sacred_func():
      ....
    my_own_var = 52
    # or in the latter scenario,
    mixedCasedVariable = 81

  5.Global Variable Names
  The conventions are about the same as those for functions,
    my_global_var = "everywhere"

  6.Method Names and Instance Variables
  Use the function naming rules: lowercase with words separated by underscores as necessary to improve readability. Use one leading underscore only for non-public methods and instance variables. (Although PEP8 says so, mixedCase can also be used)
    def instance_method(self):
      ...
    @classmethod
    def class_method(cls):
      ...
    @staticmethod
    def static_method():
      ...

  7.Function and Method Arguments
  Always use 'self' for the first argument to instance methods. Always use cls for the 'first' argument to class methods,
    # Example of different method types: (https://levelup.gitconnected.com/method-types-in-python-2c95d46281cd)
    class MethodTypes:

      name = "Ragnar"

      def instance_method(self):
        # Creates an instance atribute through keyword self
        self.lastname = "Lothbrock"
        print(self.name)
        print(self.lastname)

      @classmethod
      def class_method(cls):
        # Access a class atribute through keyword cls
        cls.name = "Lagertha"
        print(cls.name)

      @staticmethod
      def static_method():
        print("This is a static method")

    # Creates an instance of the class
    m = MethodTypes()
    # Calls instance method
    m.instance_method()
    
    MethodTypes.class_method()
    MethodTypes.static_method()

  8.Constants
  Constants are usually defined on a module level and written in all capital letters with underscores separating words,
    MAX_OVERFLOW
_______________________________________________________________________________

- There is no type declaration while creating variables in Python,
    a = 32
    b = "python"

- Comments in python are written by square '#' and it doesn't support multi-line commenting.

- String concetenation,
    "python" + " three" #'python three'

- 2 * 2 #4
  "ab" * 2 #'abab'